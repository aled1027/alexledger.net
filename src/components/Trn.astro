---
// TODO:
// 1. Convert the page processing to js
// 2. Make a UI with text box inputs for:
//  a. URL
//  b. openai API key
// 3. Run it
// 4. Make a super crude loading indicator
---

<textarea
  id="code-input"
  style="width: 100%; height: 300px;"
  placeholder="Paste your edge list here"></textarea>
<div id="container"></div>

<script is:inline src="https://d3js.org/d3.v4.min.js"></script>
<script is:inline>
  function computeDepth(nodes, edges) {
    // Initialize the depth of all nodes to -1 (undefined)
    for (const node of nodes) {
      node.depth = -1;
    }

    // Helper function to perform depth-first traversal
    function dfs(node, currentDepth, visited) {
      if (visited.has(node.label)) return; // Prevent revisiting nodes
      visited.add(node.label); // Mark the node as visited

      if (node.depth < currentDepth) {
        node.depth = currentDepth;
      }

      if (edges[node.label]) {
        for (const neighborLabel of edges[node.label]) {
          const neighbor = nodes.find((n) => n.label === neighborLabel);
          dfs(neighbor, node.depth + 1, visited);
        }
      }

      visited.delete(node.label); // Unmark the node as visited (optional)
    }

    // Find all nodes with no incoming edges (roots)
    const nodeLabels = nodes.map((n) => n.label);
    const incomingEdges = new Set(Object.values(edges).flat());
    const roots = nodeLabels.filter((label) => !incomingEdges.has(label));

    // Compute depth starting from each root
    for (const rootLabel of roots) {
      const root = nodes.find((n) => n.label === rootLabel);
      dfs(root, 0, new Set());
    }
  }

  function computePositions(nodes, edges) {
    const depths = [...new Set(nodes.map((n) => n.depth))].sort(
      (a, b) => a - b
    );
    for (const depth of depths) {
      const nodesAtDepth = nodes.filter((n) => n.depth === depth);
      row = 0;

      for (const node of nodesAtDepth) {
        let length = 1;
        const nodeEdges = edges[node.label];
        if (!!nodeEdges && nodeEdges.length > 0) {
          const nextNode = nodes.find((n) => n.label === nodeEdges[0]);
          length = nextNode.depth - node.depth;
        }

        // compute indegree
        let indegreeHeight = 0;
        for (const n of nodes) {
          const nEdges = edges[n.label];
          if (nEdges && nEdges.includes(node.label)) {
            indegreeHeight += n.height;
          }
        }
        const baseHeight = 120;
        const baseWidth = 155;
        const height = Math.max(indegreeHeight, baseHeight);

        node.row = row;
        node.col = depth;
        node.length = length;
        row += height / baseHeight; /* This could be more elegant */

        // Compute the coordinates

        node.top = node.row * baseHeight;
        node.left = node.col * baseWidth;
        node.width = baseWidth * node.length;
        node.height = Math.max(indegreeHeight, baseHeight);
      }
    }
  }

  function addToDom(nodes) {
    console.log("Adding to dom");
    const container = d3.select("#container");
    for (const node of nodes) {
      container
        .append("div")
        .style("left", `${node.left}px`)
        .style("top", `${node.top}px`)
        .style("height", `${node.height}px`)
        .style("width", `${node.width}px`)
        .attr("class", "node")
        .text(node.label);
    }
  }

  function getNodesFromEdges(edges) {
    // Get the nodes from the edges
    const nodeSet = new Set();
    for (const node of Object.keys(edges)) {
      nodeSet.add(node);
      for (const node2 of edges[node]) {
        nodeSet.add(node2);
      }
    }
    const nodes = Array.from(nodeSet).map((label) => ({ label }));
    return nodes;
  }

  function renderGraph(edges) {
    const nodes = getNodesFromEdges(edges);
    computeDepth(nodes, edges);
    computePositions(nodes, edges);
    addToDom(nodes);
  }

  document.getElementById("code-input").addEventListener("input", (event) => {
    const graphFromUser = event.target.value;
    try {
      const edges = JSON.parse(graphFromUser);
      renderGraph(edges);
    } catch (error) {
      console.error("Error executing code:", error);
    }
  });
</script>

<style is:inline>
  .node {
    border: 2px solid transparent;
    background-clip: padding-box;
    background-color: oklch(90% 0.1 143);
    line-height: 1.5em;
    padding: 0.5rem;
    box-sizing: border-box;
    position: absolute;

    font-size: 1.25rem;
    text-wrap: balance;
    text-align: center;
    display: grid;
    place-content: center;
  }

  #container {
    position: relative;
    height: 1000px;
  }
</style>
