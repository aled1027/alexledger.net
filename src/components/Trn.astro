---

---

<textarea
  id="code-input"
  style="width: 100%; height: 300px;"
  placeholder="Paste your JavaScript code here"></textarea>
<div id="container"></div>

<script is:inline src="https://d3js.org/d3.v4.min.js"></script>
<script is:inline>
  // const edges = {
  //   A: ["C"],
  //   B: ["C"],
  //   C: ["E"],
  //   D: ["E"],
  //   E: [],
  // };

  // const edges = {
  //   A: ["C"],
  //   B: ["D"],
  //   C: ["E"],
  //   D: ["E"],
  //   E: [],
  // };

  // const edges = {
  //   "3 C water": ["Boil water"],
  //   "1 C pasta": ["Cook water"],
  //   "Boil water": ["Cook water"],
  //   "Cook water": ["Cook pasta"],
  //   "Cook pasta": ["Drain pasta"],
  //   "Drain pasta": ["Return pasta to pot"],
  //   "2 tbsp olive oil": ["Return pasta to pot"],
  //   "1 C tomatoes": ["Return pasta to pot"],
  //   "1/2 C cat food": ["Return pasta to pot"],
  // };

  // const edges = {
  //   "2 1/4 cups quick oats": ["Combine dry ingredients"],
  //   "1 1/2 cups crispy rice cereal": ["Combine dry ingredients"],
  //   "2 Tablespoons ground flaxseed": ["Combine dry ingredients"],
  //   "6 Tablespoons butter": ["Microwave wet ingredients"],
  //   "Combine dry ingredients": ["Mix all together"],
  //   "1/3 cup honey": ["Microwave wet ingredients"],
  //   "3/4 cup packed light brown sugar": ["Microwave wet ingredients"],
  //   "1 teaspoon vanilla extract": ["Microwave wet ingredients"],
  //   "Microwave wet ingredients": ["Mix all together"],
  //   "Mix all together": ["Press into pan"],
  //   "1/2 cup mini chocolate chips": ["Mix all together"],
  //   "Press into pan": ["Refrigerate"],
  //   Refrigerate: ["Cut into bars"],
  // };

  function computeDepth(nodes, edges) {
    // Initialize the depth of all nodes to -1 (undefined)
    for (const node of nodes) {
      node.depth = -1;
    }

    // Helper function to perform depth-first traversal
    function dfs(node, currentDepth, visited) {
      if (visited.has(node.label)) return; // Prevent revisiting nodes
      visited.add(node.label); // Mark the node as visited

      if (node.depth < currentDepth) {
        node.depth = currentDepth;
      }

      if (edges[node.label]) {
        for (const neighborLabel of edges[node.label]) {
          const neighbor = nodes.find((n) => n.label === neighborLabel);
          dfs(neighbor, node.depth + 1, visited);
        }
      }

      visited.delete(node.label); // Unmark the node as visited (optional)
    }

    // Find all nodes with no incoming edges (roots)
    const nodeLabels = nodes.map((n) => n.label);
    const incomingEdges = new Set(Object.values(edges).flat());
    const roots = nodeLabels.filter((label) => !incomingEdges.has(label));

    // Compute depth starting from each root
    for (const rootLabel of roots) {
      const root = nodes.find((n) => n.label === rootLabel);
      dfs(root, 0, new Set());
    }
  }

  function computePositions(nodes, edges) {
    const depths = [...new Set(nodes.map((n) => n.depth))].sort(
      (a, b) => a - b
    );
    for (const depth of depths) {
      const nodesAtDepth = nodes.filter((n) => n.depth === depth);
      row = 0;

      for (const node of nodesAtDepth) {
        let length = 1;
        const nodeEdges = edges[node.label];
        if (!!nodeEdges && nodeEdges.length > 0) {
          const nextNode = nodes.find((n) => n.label === nodeEdges[0]);
          length = nextNode.depth - node.depth;
        }

        // compute indegree
        let indegreeHeight = 0;
        for (const n of nodes) {
          const nEdges = edges[n.label];
          if (nEdges && nEdges.includes(node.label)) {
            indegreeHeight += n.height;
          }
        }
        const baseHeight = 120;
        const baseWidth = 155;
        const height = Math.max(indegreeHeight, baseHeight);

        node.row = row;
        node.col = depth;
        node.length = length;
        row += height / baseHeight; /* This could be more elegant */

        // Compute the coordinates

        node.top = node.row * baseHeight;
        node.left = node.col * baseWidth;
        node.width = baseWidth * node.length;
        node.height = Math.max(indegreeHeight, baseHeight);
      }
    }
  }

  function addToDom(nodes) {
    console.log("Adding to dom");
    const container = d3.select("#container");
    for (const node of nodes) {
      container
        .append("div")
        .style("left", `${node.left}px`)
        .style("top", `${node.top}px`)
        .style("height", `${node.height}px`)
        .style("width", `${node.width}px`)
        .attr("class", "node")
        .text(node.label);
    }
  }

  function go(edges) {
    const nodeSet = new Set();
    for (const node of Object.keys(edges)) {
      nodeSet.add(node);
      for (const node2 of edges[node]) {
        nodeSet.add(node2);
      }
    }
    let nodes = Array.from(nodeSet).map((label) => ({ label }));
    computeDepth(nodes, edges);
    computePositions(nodes, edges);
    addToDom(nodes);
  }

  document.getElementById("code-input").addEventListener("input", (event) => {
    const graphFromUser = event.target.value;
    try {
      // TODO: it's dangerous!
      console.log("graphFromUser", graphFromUser);
      const edges = JSON.parse(graphFromUser);
      console.log("edges", edges);
      go(edges);
    } catch (error) {
      console.error("Error executing code:", error);
    }
  });
</script>

<style is:inline>
  .node {
    /* border: 3px solid tranparent; */
    /* margin: 4px; */
    border: 2px solid transparent;
    background-clip: padding-box;
    background-color: oklch(90% 0.1 143);
    line-height: 1.5em;
    padding: 0.5rem;
    box-sizing: border-box;
    position: absolute;

    font-size: 1.25rem;
    text-wrap: balance;
    text-align: center;
    display: grid;
    place-content: center;
  }

  #container {
    position: relative;
    height: 1000px;
  }
</style>
