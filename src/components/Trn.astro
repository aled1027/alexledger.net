---

---

<div id="container"></div>

<script is:inline src="https://d3js.org/d3.v4.min.js"></script>
<script is:inline>
  // const edges = {
  //   A: ["C"],
  //   B: ["C"],
  //   C: ["E"],
  //   D: ["E"],
  //   E: [],
  // };

  // const edges = {
  //   A: ["C"],
  //   B: ["D"],
  //   C: ["E"],
  //   D: ["E"],
  //   E: [],
  // };

  // const edges = {
  //   "3 C water": ["Boil water"],
  //   "1 C pasta": ["Cook water"],
  //   "Boil water": ["Cook water"],
  //   "Cook water": ["Cook pasta"],
  //   "Cook pasta": ["Drain pasta"],
  //   "Drain pasta": ["Return pasta to pot"],
  //   "2 tbsp olive oil": ["Return pasta to pot"],
  //   "1 C tomatoes": ["Return pasta to pot"],
  //   "1/2 C cat food": ["Return pasta to pot"],
  // };

  const edges = {
    "2 1/4 cups quick oats": ["Combine dry ingredients"],
    "1 1/2 cups crispy rice cereal": ["Combine dry ingredients"],
    "2 Tablespoons ground flaxseed": ["Combine dry ingredients"],
    "6 Tablespoons butter": ["Microwave wet ingredients"],
    "Combine dry ingredients": ["Mix all together"],
    "1/3 cup honey": ["Microwave wet ingredients"],
    "3/4 cup packed light brown sugar": ["Microwave wet ingredients"],
    "1 teaspoon vanilla extract": ["Microwave wet ingredients"],
    "Microwave wet ingredients": ["Mix all together"],
    "Mix all together": ["Press into pan"],
    "1/2 cup mini chocolate chips": ["Mix all together"],
    "Press into pan": ["Refrigerate"],
    Refrigerate: ["Cut into bars"],
  };

  function computeDepth(nodes, edges) {
    // Initialize the depth of all nodes to -1 (undefined)
    for (const node of nodes) {
      node.depth = -1;
    }

    // Helper function to perform depth-first traversal
    function dfs(node, currentDepth, visited) {
      if (visited.has(node.label)) return; // Prevent revisiting nodes
      visited.add(node.label); // Mark the node as visited

      if (node.depth < currentDepth) {
        node.depth = currentDepth;
      }

      if (edges[node.label]) {
        for (const neighborLabel of edges[node.label]) {
          const neighbor = nodes.find((n) => n.label === neighborLabel);
          dfs(neighbor, node.depth + 1, visited);
        }
      }

      visited.delete(node.label); // Unmark the node as visited (optional)
    }

    // Find all nodes with no incoming edges (roots)
    const nodeLabels = nodes.map((n) => n.label);
    const incomingEdges = new Set(Object.values(edges).flat());
    const roots = nodeLabels.filter((label) => !incomingEdges.has(label));

    // Compute depth starting from each root
    for (const rootLabel of roots) {
      const root = nodes.find((n) => n.label === rootLabel);
      dfs(root, 0, new Set());
    }
  }

  function computePositions(nodes, edges) {
    const depths = [...new Set(nodes.map((n) => n.depth))].sort(
      (a, b) => a - b
    );
    for (const depth of depths) {
      const nodesAtDepth = nodes.filter((n) => n.depth === depth);
      row = 0;

      for (const node of nodesAtDepth) {
        let length = 1;
        const nodeEdges = edges[node.label];
        if (!!nodeEdges && nodeEdges.length > 0) {
          const nextNode = nodes.find((n) => n.label === nodeEdges[0]);
          length = nextNode.depth - node.depth;
        }

        // compute indegree
        let indegreeHeight = 0;
        for (const n of nodes) {
          const nEdges = edges[n.label];
          if (nEdges && nEdges.includes(node.label)) {
            indegreeHeight += n.height;
          }
        }
        const baseSize = 100;
        const height = Math.max(indegreeHeight, baseSize);

        node.row = row;
        node.col = depth;
        node.length = length;
        row += height / baseSize; /* This could be more elegant */

        // Compute the coordinates

        node.top = node.row * baseSize;
        node.left = node.col * baseSize;
        node.width = baseSize * node.length;
        node.height = Math.max(indegreeHeight, baseSize);
      }
    }
  }

  function addToDom(nodes) {
    const container = d3.select("#container");
    for (const node of nodes) {
      container
        .append("div")
        .style("left", `${node.left}px`)
        .style("top", `${node.top}px`)
        .style("height", `${node.height}px`)
        .style("width", `${node.width}px`)
        .attr("class", "node")
        .text(node.label);
    }
  }

  const nodeSet = new Set();
  for (const node of Object.keys(edges)) {
    nodeSet.add(node);
    for (const node2 of edges[node]) {
      nodeSet.add(node2);
    }
  }
  let nodes = Array.from(nodeSet).map((label) => ({ label }));

  console.log(nodes);

  computeDepth(nodes, edges);
  computePositions(nodes, edges);
  addToDom(nodes);
</script>

<style is:inline>
  .node {
    border: 1px solid #ccc;
    background-color: #ffcc00;
    text-align: center;
    line-height: 1.5em;
    padding: 10px;
    box-sizing: border-box;
    position: absolute;
    font-size: 14px;
  }

  #container {
    position: relative;
    height: 1000px;
    width: 100%;
    border: 1px solid #ccc;
  }
</style>
